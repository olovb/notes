
Cognetics and UI
================

Software must be designed so that the user can easily create an accurate mental model of said software. An accurate model means a model that lets the user reason about ways to use the software and that leads to conclutions that match what a user actually can and cannot do in a given situation. The idea of a mental model must guide all development of software.


Interesting Findings
--------------------
Software designed to be consistent with users prior knowledge not more "user friendly" than software designed after how the user ought to view and operate on their data (Wright and Bason 1982).

Learning software adapted to user's familiar vocabulary not easier than learning software with other unfamiliar vocabulary (Landauer et al 1983). 

Similar tasks should be accomplished by similar actions (Barnard et al, 1983; Black and Sebrechts, 1981; Thomas and Caroll, 1981).

Users are not likely to take time to assign metadata to files (Rodden 2003).

Studies of email users show that email is often stored in a single list and rearranged on a given attribute for a given task (Whittaker 1996).


Personal Observations
---------------------
User did not understand that windows explorer and file open dialog was different representations of the same hierarchy.

User seemed to think there was a difference between opening a file from the file manager and from within an application via the file open menu.

One user did not understand that the address widget in firefox is also a bookmark search field.

One user finds locating the task bar button for a specific open window tedious [no use of spacial memory?].

One user changed keyboard layout setting by accidentaly pressing some unknown keyboard shortcut.

There is a conflict between automagical creation of files (such as backup files) and the desire to organize own files, according to one user.

File folders acting as a type of namespace are often redundant and less efficient than a common namspace and searchable contents such as in a Wiki. 

File systems lack version control mechanisms leading users to create their own version handling machinery by keeping older copies of files.

Users don't seem to know when to single click and when to double click.

One user finds that deep hierarchies are desirable but at the same time are making it tedious to find and open files.
